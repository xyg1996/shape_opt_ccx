# Standard modules
import sys
import os
import shutil
import time
import re
import logging
import subprocess
import threading
try:
    import pvsimple as pvs
except:
    pass
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtWidgets import QApplication, QDialog,QFrame
from PyQt5.QtWidgets import QApplication,QFileDialog
from PyQt5 import uic
from PyQt5.QtGui import QPixmap
from PyQt5.QtCore import QDir
from PyQt5.Qt import *
from PyQt5.QtCore import QObject, pyqtSignal, pyqtSlot
from PyQt5.QtWidgets import QWidget, QApplication, QMainWindow
from PyQt5 import Qt as Q

sys_path = os.path.abspath(__file__)
sys_path = os.path.dirname(sys_path)
sys_path = os.path.join(sys_path, '..') # change_dir
sys_path = os.path.normpath(sys_path)
sys_path = os.path.realpath(sys_path)
if sys_path not in sys.path:
    sys.path.insert(0, sys_path)
# External modules
from PyQt5 import QtWidgets, uic
from path import p
from model.parsers.mesh import Mesh
from model import m
from model.kom import KOM
from model.kom import ItemType, Implementation
from settings import s
import log
#from importer import i
#from tree2 import self
#from .shape_opt_ui import Ui_Form
if (p.op_sys=="linux"):
    from ....post import (ResultFile, PlotWindow,
                ColorRep, WarpRep, ModesRep, BaseRep,
                pvcontrol, show_min_max, selection_probe, selection_plot,
                get_active_selection, get_pv_mem_use, dbg_print,
                RESULTS_PV_LAYOUT_NAME, RESULTS_PV_VIEW_NAME)

    from ... import ActionType, clipboard_text
    from ....common import (MeshElemType, MeshGroupType, FilesSupplier, common_filters, connect,
    #                       debug_mode, get_cmd_groups, get_cmd_mesh, get_file_name,
    #                       重新定义 get_cmd_groups, get_cmd_mesh
                        debug_mode, get_file_name,get_medfile_meshes,get_medfile_groups,
                        get_medfile_groups_by_type,is_child, is_medfile, is_reference,
                        is_subclass,is_valid_group_name, load_icon, translate,
                        )
    from ....common.extfiles import external_file_export_to_med, external_files
    from ...salomegui_utils import *

class Main(QtWidgets.QMainWindow):
    meshFileChanged = Q.pyqtSignal(str, str, float, bool)
    meshGroupCheck = Q.pyqtSignal(str, str, str, int)
    meshGroupCheckColor = Q.pyqtSignal(str, str, str, int,list)
    meshGroupUnCheck = Q.pyqtSignal(str, str, str, int)
    #beamsectionChanged = Q.pyqtSignal(int)
    def __init__(self,input,xml=p.main_xml):
        super(Main,self).__init__()
        self.pv_view = None
        self.res = self.ren_view = self.default_file_root = None
        self.meshlist_all=[]
        self.minmax6 = None
        self.previous = {}
        self.meshview = input
        print(xml)
        uic.loadUi(xml, self)
        self.model = QtGui.QStandardItemModel()
        self.treeView.setModel(self.model)

        if os.path.exists(p.default_inp):
            start_model=p.default_inp
            #self.import_file(start_model)
            if os.path.exists(p.default_med) and p.op_sys=="linux":
                #self.open_file(p.default_med)
                connect(self.meshFileChanged, self.meshview.displayMEDFileName)
        else:
            self.generateTreeView()

        # treeView信号与槽
        self.treeView.doubleClicked.connect(self.doubleClicked)
        self.treeView.clicked.connect(self.clicked)
        self.treeView.customContextMenuRequested.connect(self.rightClicked)
        self.treeView.expanded.connect(self.expanded_or_collapsed)
        self.treeView.collapsed.connect(self.expanded_or_collapsed)

        if (p.op_sys=="linux"):
            # Highlight信号与槽
            connect(self.meshGroupCheckColor, self.meshview.displayMeshGroupcolor)
            connect(self.meshGroupUnCheck, self.meshview.undisplayMeshGroup)
            #self.homedir = os.environ['HOME']

        # File actions
        self.action_file_import.triggered.connect(lambda: self.import_file(None))
        self.action_file_settings.triggered.connect(s.open)

        # Job actions
        self.action_job_write_input.triggered.connect(
        lambda: self.write_input(KOM.get_inp_code_as_lines()))
        self.action_job_edit_inp.triggered.connect(lambda: self.open_inp())
        #self.show()
        # self.ui = Ui_Form()
        # self.ui.setupUi(self)
        ## 启用外部进程
        self.process = QtCore.QProcess(self)
        #self.process1 = QtCore.QProcess(self)
        self.process2 = QtCore.QProcess(self)
        #self.process.readyRead.connect(self.dataReady)
        #self.process2.readyRead.connect(self.dataReady)
        #self.init_paraview()
        #self.change_element_pro() # 自动写入默认属性
        self.process = Q.QProcess(self)
        self.file_name = ''
        self.nom_med = ''
        self.curr_dir = '/share/simforge_home/nsccwx/xyg/salome'
        # self.med_file_name = 'simple_test.med'
        # self.med_file_dir = os.path.join(self.curr_dir,self.med_file_name)
        self.mesh_group = []
        self.current_mesh_group = []
        # print(self.med_file_dir)
        # print(type(self.med_file_dir))
        # 确认按钮
        #self.ui.pushButton_ok.clicked.connect(self.cal_spacing)
        #connect(self.meshFileChanged, self.meshview.displayMEDFileName)
        # self.ui.pushButton_2.clicked.connect(self.open_file)
        # self.home_path = os.environ['HOME']
        # print("CWD",str(self.home_path))

        # # 位移条件
        # connect(self.ui.pushButton_4.clicked, self._addRow)
        # connect(self.ui.pushButton_5.clicked,self._removeSelectedRow)
        # self.ui.tableWidget.setSelectionBehavior(Q.QTableWidget.SelectRows)  # Selecting single items.选中单个单元格,即选中整行
        # #self.ui.tableWidget.cellClicked.connect(self.current_combo_text)
        # self.ui.tableWidget.currentCellChanged.connect(self.current_combo_text)

        # # 载荷条件
        # connect(self.ui.pushButton_7.clicked, self._addRow_2)
        # connect(self.ui.pushButton_8.clicked,self._removeSelectedRow_2)
        # #self.ui.tableWidget_2.cellClicked.connect(self.current_combo_text_2)
        # self.ui.tableWidget_2.currentCellChanged.connect(self.current_combo_text_2)
        # self.ui.tableWidget_2.setSelectionBehavior(Q.QTableWidget.SelectRows)  # Selecting single items.选中单个单元格,即选中整行
        # #self.ui.tableWidget_2.cellClicked.connect(self.current_combo_text)
        # #self.mesh_group_combo = Q.QComboBox(self)
        
        # # 优化约束条件
        # connect(self.ui.pushButton_12.clicked, self._addRow_3)
        # connect(self.ui.pushButton_13.clicked,self._removeSelectedRow_3)
        # # try:
        # #     connect(self.mesh_group_combo.currentIndexChanged,self._highlight_mesh_group)
        # # except:
        # #     print("error!")

        # connect(self.ui.comboBox.currentIndexChanged,self._highlight_mesh_group_2)
        # connect(self.ui.tabWidget.currentChanged,self._highlight_mesh_group_2)
        

        # #self.ui.pushButton_11.clicked.connect(self._highlight_mesh_group)
        # # # 还原按钮
        # # self.ui.pushButton_reset.clicked.connect(self.reset)
        # # # 梁属性赋予高亮显示
        # # #self.ui.tabWidget_2.currentChanged.connect(self.cal_spacing)
        # # self.ui.tabWidget_2.currentChanged['int'].connect(self.highlight_beams)
        # # #self.beamsectionChanged.connect(self.highlight_beams)
        



        # self.ui.pushButton.clicked.connect(self.med2inp)
        # # 单元属性应用按钮 
        # self.ui.pushButton_beam.clicked.connect(self.change_element_pro)
        # self.ui.apply.clicked.connect(self.change_element_pro)
        # # 提交计算
        # self.ui.pushButton_4.clicked.connect(self.submit)
        # self.ui.pushButton_break.clicked.connect(self.show_result)
        #self.ui.tabWidget.currentChanged['int'].connect(self.main_tab_change)
    def generateTreeView(self):
        """Recursively generate treeView widget items based on KOM."""
        self.model.clear() # remove all items and data from tree
        parent_element = self.model.invisibleRootItem() # top element in QTreeView
        self.addToTree(parent_element, KOM.root.items) # pass top level groups

    def addToTree(self, parent_element, items):
        """Used with generateTreeView() - implements recursion."""
        for item in items:

            # Add to the tree only needed item_types
            allowed = [ItemType.GROUP, ItemType.KEYWORD,
                ItemType.IMPLEMENTATION]
            if item.itype not in allowed:
                continue

            # Check if there are keywords with implementations
            if not s.show_empty_keywords \
                and not item.count_implementations() \
                and item.itype != ItemType.IMPLEMENTATION:
                continue

            # Create tree_element
            tree_element = QtGui.QStandardItem(item.name)
            tree_element.setData(item)
            parent_element.appendRow(tree_element)

            # Set text color for tree_element
            brush = QtGui.QBrush()
            brush.setColor(QtCore.Qt.gray)
            if item.is_active():
                brush.setColor(QtCore.Qt.black)
                # Bold font for implementations
                if item.itype == ItemType.IMPLEMENTATION:
                    font = QtGui.QFont()
                    font.setBold(True)
                    tree_element.setFont(font)
            tree_element.setForeground(brush)

            # Expand / collapse
            if item.expanded:
                self.treeView.expand(tree_element.index())
            else:
                self.treeView.collapse(tree_element.index())

            # Add icon to each keyword in tree
            icon_name = item.name.replace('*', '') + '.png'
            icon_name = icon_name.replace(' ', '_')
            icon_name = icon_name.replace('-', '_')
            icon_path = os.path.join(p.img, 'icon_' + icon_name.lower())
            icon = QtGui.QIcon(icon_path)
            tree_element.setIcon(icon)

            # Organize recursion
            impls = item.get_implementations()
            if len(impls):
                self.addToTree(tree_element, impls)
            else:
                self.addToTree(tree_element, item.items)

    def split_on_blocks(self, inp_doc):
        """Split inp_doc on blocks."""
        self.keyword_blocks = []
        i = 0
        regex = r'^\*[\w\s-]+'
        while i < len(inp_doc):
            match = re.match(regex, inp_doc[i])
            if match is not None:
                keyword_name = match.group(0).strip()

                # Comments before the block
                comments = []
                counter = 0 # amount of comment lines
                while i > counter and inp_doc[i-counter-1].startswith('**'):
                    counter += 1
                    comments.insert(0, inp_doc[i-counter])

                # Lead line - a line(s) with keyword
                lead_line = inp_doc[i].rstrip()
                while lead_line.endswith(','):
                    i += 1
                    lead_line = lead_line + ' ' + inp_doc[i].rstrip()

                i += 1
                start = i # start of data lines
                while i < len(inp_doc):
                    match = re.match(regex, inp_doc[i])
                    if match is not None:
                        i -= 1
                        break # reached next keyword
                    i += 1

                # Comments after the block (if not EOF)
                if i < len(inp_doc) - 1:
                    while inp_doc[i].startswith('**'):
                        i -= 1
                end = i # index of block end

                data_lines = inp_doc[start:end+1]
                b = Block(keyword_name, comments, lead_line, data_lines)
                # b.print_debug_info()
                self.keyword_blocks.append(b)

            i += 1

    def parse_blocks(self):
        """Create keyword implementations."""
        parent = KOM.root
        messages = []

        for kwb in self.keyword_blocks:

            # Create implementations (for example, MATERIAL-1)
            kw = None
            while kw is None and parent is not None: # root has None parent
                kw = KOM.get_top_keyword_by_name(parent, kwb.keyword_name)
                if kw is not None:
                    parent = Implementation(kw, kwb.get_inp_code())
                else:
                    parent = parent.parent
            if kw is None:
                parent = KOM.root
                msg = 'Misplaced or wrong keyword {}.'\
                    .format(kwb.keyword_name)
                if msg not in messages:
                    messages.append(msg)
                    logging.warning(msg)

    def import_file(self, file_name):
        """Main method in the class"""
        #from gui.job import j
        self.j = Job()
        # if file_name is None and self.w is None:
        #     msg = 'file_name and self.w are None.'
        #     raise SystemExit(msg)

        if file_name is None:
            # file_name = QtWidgets.QFileDialog.getOpenFileName(self, \
            #     'Import INP/FBD/UNV file', p.app_home_dir, \
            #     'INP (*.inp);;FBD (*.fbd);;UNV (*.unv)')[0]
            try:
                with open(p.user_settings, 'r') as f:
                    for line in f.readlines():
                         if(line.find('self.working_dir') == 0):
                            self.current_working_dir = line.split()[2]
                            print('current_working_dir:',self.current_working_dir)
                

                file_name = QtWidgets.QFileDialog.getOpenFileName(self, \
                    'Import INP/FBD/UNV file', self.current_working_dir[1:-1], \
                    'INP (*.inp);;FBD (*.fbd);;UNV (*.unv)')[0]
            except:
                file_name = QtWidgets.QFileDialog.getOpenFileName(self, \
                'Import INP/FBD/UNV file', p.user_homedir, \
                'INP (*.inp);;FBD (*.fbd);;UNV (*.unv)')[0]

        if file_name is not None and len(file_name):
            #self.w.textEdit.clear()

            # Update job instance before the tree regeneration
            # A new logger handler is created here
            self.j.generate(file_name[:-4] + '.inp')
            if (p.op_sys=="linux"):
                self.open_file(file_name[:-4] + '.med')

            # Show model name in window title
            title = 'CalculiX Advanced Environment - ' + self.j.name
            self.setWindowTitle(title)

            from gui import stdout
            stdout.stop_readers()

            # Generate new KOM without implementations
            KOM.__init__()

            inp_files = []
            if file_name.lower().endswith('.inp'):
                inp_files.append(self.j.inp)

            # Convert UNV to INP
            if file_name.lower().endswith('.unv'):
                self.j.convert_unv()
                inp_files.append(self.j.inp)
                if not os.path.isfile(self.j.inp):
                    logging.error('Can not convert\n' + self.j.unv)
                    return

            # Pass FBD to CGX
            # from gui import cgx
            # if file_name.lower().endswith('.fbd'):
            #     """Get list of newly created or updated files."""
            #     flist_before = {}
            #     for f in os.listdir(os.path.dirname(file_name)):
            #         fname = pathlib.Path(f)
            #         flist_before[f] = fname.stat().st_ctime
            #     cgx.restart_and_read_fbd(file_name)
            #     flist_after = os.listdir(os.path.dirname(file_name))
            #     for f in flist_after:
            #         if not f in flist_before:
            #             inp_files.append(f)
            #         else:
            #             modified_before = flist_before[f]
            #             fname = pathlib.Path(f)
            #             modified_after = fname.stat().st_ctime
            #             if modified_before != modified_after:
            #                 inp_files.append(f)

            # Get INP code from all model files
            logging.info('Loading model files...')
            inp_doc = []
            for f in inp_files:
                logging.debug(f)
                inp_doc.extend(read_lines(f))

            # Split INP code on blocks - fill self.keyword_blocks
            self.split_on_blocks(inp_doc)

            # Parse keyword_blocks and enrich KOM with parsed objects
            self.parse_blocks()

            # Add parsed implementations to the tree
            #from tree.tree import t
            #t = Main
            self.generateTreeView()

            # Parse mesh
            # TODO Use Mesh instead of m.Mesh
            from model.parsers import mesh
            m.Mesh = mesh.Mesh(blocks=self.keyword_blocks)

            # Open a new non-empty model in CGX
            from settings import s
            if not s.start_cgx_by_default:
                msg = '"Settings -> Start CGX by default" is unchecked.'
                logging.warning(msg)
                return
            if not len(m.Mesh.nodes):
                msg = 'Empty mesh, CGX will not start!'
                logging.warning(msg)
                return

            has_nodes = len(m.Mesh.nodes)
            # cgx.open_inp(j.inp, has_nodes)

    def write_input(self, lines):
        """Write the whole model inp_code into the output .inp-file.
        Is called from menu 'Job -> Write input'.
        Reinitialize job because of possible file_name change.
        """
        file_name = QtWidgets.QFileDialog.getSaveFileName(None, \
            'Write INP file', self.j.dir, \
            'Input files (*.inp)')[0]
        if len(file_name):
            if not file_name.endswith('.inp'):
                file_name += '.inp'
            with open(file_name, 'w') as f:
                f.writelines(lines)

    def open_inp(self):
        """Open INP file in external text editor."""
        if os.path.isfile(s.path_editor):
            if os.path.isfile(self.j.inp):
                command = [s.path_editor, self.j.inp]
                p = subprocess.Popen(command)
                return p
            else:
                msg = 'File not found:\n' \
                    + self.j.inp \
                    + '\nWrite input first.'
                logging.error(msg)
                return None
        else:
            msg = 'Wrong path to text editor:\n' \
                + s.path_editor \
                + '\nConfigure it in File->Settings.'
            logging.error(msg)
            return None

    def run_master_dialog(self, i):
        """Generate dialog window and show it."""
        import gui.dialog
        self.mw = gui.dialog.KeywordDialog(i) # one argument for init_wrapper()

        # Actions
        self.mw.buttonBox.accepted.connect(self.mw.ok)
        self.mw.buttonBox.button(QtWidgets.QDialogButtonBox.Reset).clicked.connect(self.mw.reset)
        #self.mw.buttonBox.helpRequested.connect(self.open_help)

        # if s.align_windows:
        #     connection.align_master(self.mw)

        if s.show_help:
            self.open_help(False)
        d = self.mw.exec()
        #self.kill_slave()
        return d

# Prepare to import model

    def doubleClicked(self):
        """Double click on treeView item: edit the keyword via dialog."""
        index = self.treeView.selectedIndexes()[0] # selected item index
        tree_element = self.model.itemFromIndex(index) # treeView item obtained from 'index'
        item = tree_element.data() # now it is GROUP, KEYWORD or IMPLEMENTATION

        # Double click on GROUP doesn't create dialog
        allowed_types = [ItemType.KEYWORD, ItemType.IMPLEMENTATION]
        if not item or item.itype not in allowed_types:
            return

        if not item.active:
            kw_name = item.get_parent_keyword_name()
            msg = 'Please, create {} first.'.format(kw_name)
            logging.warning(msg)
            return

        # Exec dialog and recieve answer
        # Process response from dialog window if user pressed 'OK'
        if self.run_master_dialog(item): # 0 = cancel, 1 = ok

            # The generated piece of .inp code for the CalculiX input file
            inp_code = self.mw.ok() # list of strings

            # Create implementation object for keyword
            if item.itype == ItemType.KEYWORD:
                impl = Implementation(item, inp_code) # create keyword implementation

                # Regenerate tree_element children
                tree_element.removeRows(0, tree_element.rowCount()) # remove all children
                self.addToTree(tree_element, item.get_implementations()) # add only implementations

                # Reparse mesh or constraints
                # TODO Use Mesh without m
                # m.Mesh.reparse(inp_code)
                reparsed = Mesh(icode=inp_code, old=m.Mesh)
                if m.Mesh is not None:
                    m.Mesh.updateWith(reparsed)
                self.clicked() # rehighlight

            # Replace implementation object with a new one
            elif item.itype == ItemType.IMPLEMENTATION:
                # Remove old one
                parent = tree_element.parent() # parent treeView item
                keyword = parent.data() # parent keyword for implementation
                keyword.items.remove(item) # remove implementation from keyword items

                # Add new one
                impl = Implementation(keyword, inp_code, name=item.name)
                tree_element.setData(impl)

                # Reparse mesh or constraints
                reparsed = Mesh(icode=inp_code, old=m.Mesh)
                m.Mesh.updateWith(reparsed)
                self.clicked() # rehighlight

    def clicked(self):
        """Highlight node sets, element sets or surfaces."""
        
        if not hasattr(self, 'treeView'):
            return

        # Debug for Ctrl+Click
        if not len(self.treeView.selectedIndexes()):
            return

        # Highlight only when INP is opened
        # if wf.sw is None:
        #     return
        # if not (p.path_cgx + ' -c ') in wf.sw.cmd:
        #     return

        index = self.treeView.selectedIndexes()[0] # selected item index
        tree_element = self.model.itemFromIndex(index) # treeView item obtained from 'index'
        item = tree_element.data() # now it is GROUP, KEYWORD or IMPLEMENTATION

        # Highlight entities
        if item and item.itype == ItemType.IMPLEMENTATION:
            ipn_up = item.parent.name.upper()
            _set = []

            i = 0
            while item.inp_code[i].startswith('**'):
                i += 1
            lead_line = item.inp_code[i]

            if ipn_up == '*NSET' or ipn_up == '*NODE':
                match = re.search('NSET\s*=\s*([\w\!\#\%\$\&\"\'\(\)\*\=\+\-\.\/\:\;\<\>\?\@\[\]\^\_\`\{\\\|\}\~]*)', lead_line.upper())
                if match: # if there is NSET attribute
                    name = lead_line[match.start(1):match.end(1)] # node set name
                    # print("name:",name.upper())
                    # print("m.Mesh.nsets:",m.Mesh.nsets)
                    # print("type(m.Mesh.nsets):",type(m.Mesh.nsets))
                    # print("m.Mesh.nsets[name.upper()]:",m.Mesh.nsets[name.upper()])
                    # print("m.Mesh.nsets['FIX_FACE']:",m.Mesh.nsets['FIX_FACE'])
                    if name.upper() in m.Mesh.nsets:
                        self.highlight_node(name)
                        # try:
                        #     grtype = MeshGroupType.GNode
                        #     all_groups = get_medfile_groups(self.file_name, None, grtype)
                        #     print('all_groups:',all_groups)
                        #     var = name
                        #     print("var:",var)
                        #     rgb = [0,1,0.333333]

                        #     for g in all_groups:
                        #         self.meshGroupUnCheck.emit(self.file_name,
                        #                                     self.nom_med,
                        #                                     g,
                        #                                     grtype)

                        #     self.meshGroupCheckColor.emit(self.file_name,
                        #                                     self.nom_med,
                        #                                     var,
                        #                                     grtype,
                        #                                     rgb)
                        # except:
                        #     print("design area mesh highlight error!")
                    else:
                        print("error!")

            elif ipn_up == '*ELSET' or ipn_up == '*ELEMENT':
                match = re.search('ELSET\s*=\s*([\w\!\#\%\$\&\"\'\(\)\*\=\+\-\.\/\:\;\<\>\?\@\[\]\^\_\`\{\\\|\}\~]*)', lead_line.upper())
                if match: # if there is ELSET attribute
                    name = lead_line[match.start(1):match.end(1)] # element set name
                    if name.upper() in m.Mesh.elsets:
                        self.highlight_elem(name)
                    else:
                        print("error!")

            # Highlight mesh entities
        #     if ipn_up == '*NSET' or ipn_up == '*NODE':
        #         match = re.search('NSET\s*=\s*([\w\!\#\%\$\&\"\'\(\)\*\=\+\-\.\/\:\;\<\>\?\@\[\]\^\_\`\{\\\|\}\~]*)', lead_line.upper())
        #         if match: # if there is NSET attribute
        #             name = lead_line[match.start(1):match.end(1)] # node set name
        #             if name in m.Mesh.nsets:
        #                 wf.connection.post('plot n ' + name)

        #     elif ipn_up == '*ELSET' or ipn_up == '*ELEMENT':
        #         match = re.search('ELSET\s*=\s*([\w\!\#\%\$\&\"\'\(\)\*\=\+\-\.\/\:\;\<\>\?\@\[\]\^\_\`\{\\\|\}\~]*)', lead_line.upper())
        #         if match: # if there is ELSET attribute
        #             name = lead_line[match.start(1):match.end(1)] # element set name
        #             if name in m.Mesh.elsets:
        #                 wf.connection.post('plot e ' + name)

        #     elif ipn_up == '*SURFACE':

        #         # Surface type - optional attribute
        #         stype = 'ELEMENT' # 'ELEMENT' or 'NODE'
        #         match = re.search('\*SURFACE\s*,.*TYPE\s*=\s*(\w*)', lead_line.upper())
        #         if match:
        #             stype = lead_line[match.start(1):match.end(1)]

        #         match = re.search('NAME\s*=\s*([\w\!\#\%\$\&\"\'\(\)\*\=\+\-\.\/\:\;\<\>\?\@\[\]\^\_\`\{\\\|\}\~]*)', lead_line.upper())
        #         name = lead_line[match.start(1):match.end(1)] # surface name
        #         if stype == 'ELEMENT':
        #             wf.connection.post('plot f ' + name)
        #         elif stype=='NODE':
        #             wf.connection.post('plot f ' + name)

        #     # Highlight Loads & BC
        #     elif ipn_up in ['*BOUNDARY', '*CLOAD', '*CFLUX']:
        #         for line in item.inp_code[1:]:
        #             line = line.strip()
        #             n = line.replace(',', ' ').split()[0]
        #             try:
        #                 # Single node number
        #                 _set.append(int(n))
        #             except ValueError as err:
        #                 # Nodes in node set
        #                 _set.extend([n.num for n in m.Mesh.nsets[n].items])
        #                 pass
        #         # self.VTK.highlight(set(_set), 1) # 1 = vtk.vtkSelectionNode.POINT

        # # else:
        # #     self.deselect_cgx_sets()

    def rightClicked(self):
        """Context menu for right click."""
        self.myMenu = QtWidgets.QMenu('Menu', self.treeView)

        try:
            index = self.treeView.selectedIndexes()[0] # selected item index
            tree_element = self.model.itemFromIndex(index) # treeView item obtained from 'index'
            item = tree_element.data() # now it is GROUP, KEYWORD or IMPLEMENTATION

            #print("item:",item)
            # Context menu for any keyword and implementations
            if item:
                if item.itype == ItemType.IMPLEMENTATION:

                    # 'Edit' action
                    action_edit_implementation = QtWidgets.QAction('Edit', self.treeView)
                    self.myMenu.addAction(action_edit_implementation)
                    action_edit_implementation.triggered.connect(self.doubleClicked)

                    # 'Delete' action
                    action_delete_implementation = QtWidgets.QAction('Delete', self.treeView)
                    self.myMenu.addAction(action_delete_implementation)
                    action_delete_implementation.triggered.connect(self.actionDeleteImplementation)

                if item.itype == ItemType.KEYWORD:

                    # 'Create' action
                    action_create_implementation = QtWidgets.QAction('Create', self.treeView)
                    self.myMenu.addAction(action_create_implementation)
                    action_create_implementation.triggered.connect(self.doubleClicked)

            # Add splitter
            self.myMenu.addSeparator()

        except IndexError:
            pass

        # Context menu elements which always present
        if s.show_empty_keywords:
            action_show_hide = QtWidgets.QAction('Hide empty containers', self.treeView)
        else:
            action_show_hide = QtWidgets.QAction('Show empty containers', self.treeView)
        self.myMenu.addAction(action_show_hide)
        action_show_hide.triggered.connect(self.actionShowHide)

        action_collapse_expand = QtWidgets.QAction('Collapse/expand all', self.treeView)
        self.myMenu.addAction(action_collapse_expand)
        action_collapse_expand.triggered.connect(self.action_collapse_expand_all)

        self.myMenu.exec_(QtGui.QCursor.pos())
    
    def actionShowHide(self):
        """Show/Hide empty treeView items."""
        s.show_empty_keywords = not s.show_empty_keywords
        s.save() # save 'show_empty_keywords' value in settings
        if s.expanded:
            self.treeView.collapseAll()
        else:
            self.treeView.expandAll()
        self.generateTreeView()

    def action_collapse_expand_all(self):
        """Expand or collapse all treeView items."""
        if s.expanded:
            self.treeView.collapseAll()
        else:
            self.treeView.expandAll()
        s.expanded = not s.expanded
        s.save()

    def actionDeleteImplementation(self):
        """Delete keyword implementation from KOM."""

        def hide_parent(tree_element):
            # To hide current item/brunch it should be empty 'keyword' or 'group'
            if not s.show_empty_keywords \
                and not tree_element.hasChildren() \
                and tree_element.data().itype != ItemType.IMPLEMENTATION:

                # Hide current item/brunch from tree via calling parent.removeRow
                parent = tree_element.parent()
                if not parent:
                    parent = self.model.invisibleRootItem()
                parent.removeRow(tree_element.row())

                if parent != self.model.invisibleRootItem():
                    hide_parent(parent)

        index = self.treeView.selectedIndexes()[0] # selected item index
        tree_element = self.model.itemFromIndex(index) # treeView item obtained from 'index'
        item = tree_element.data() # now it is GROUP, KEYWORD or IMPLEMENTATION

        if item and item.itype == ItemType.IMPLEMENTATION:

            # Confirmation dialog to delete implementation
            answer = QtWidgets.QMessageBox.question(None,
                item.name, 'OK to delete ' + item.name + '?',
                QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No,
                QtWidgets.QMessageBox.Yes)

            # If confirmed
            if answer == QtWidgets.QMessageBox.Yes:

                parent = tree_element.parent() # parent treeView item
                keyword = parent.data() # parent keyword for implementation
                keyword.items.remove(item) # remove implementation from keyword items

                # Regenerate parent children
                parent.removeRows(0, parent.rowCount()) # remove all children
                self.addToTree(parent, keyword.items)

                if not s.show_empty_keywords:
                    hide_parent(parent)

    def expanded_or_collapsed(self, index):
        """Change KOM item 'expanded' variable when user interacts with treeView."""
        tree_element = self.model.itemFromIndex(index) # treeView item obtained from 'index'
        item = tree_element.data() # now it is GROUP, KEYWORD or IMPLEMENTATION
        if item:
            item.expanded = not item.expanded


    def open_file(self,path):
        # fileDir,fileType = QtWidgets.QFileDialog.getOpenFileName(self, "选取文件", os.getcwd(), 
        # "All Files(*);;Text Files(*.txt)")
        # fileDir,fileType = QtWidgets.QFileDialog.getOpenFileName(self, "选取文件", path, 
        # "All Files(*);;Text Files(*.txt)")
        fileDir = path
        self.geoPath = fileDir
        fileName = os.path.basename(fileDir)
        self.med_father_dir = os.path.dirname(fileDir)
        # print("fileName:",fileName)
        # print("fileType:",fileType)
        # print("med_father_dir:",self.med_father_dir)
        #self.blade.setText(self.geoPath)
        self.med_file_name = fileName
        #self.med_file_dir = os.path.join(self.curr_dir,self.med_file_name)
        self.med_file_dir = fileDir
        self.startmesh(self.med_file_dir)


    def startmesh(self,fname):
        #import subprocess
        self.meshlist_all = [fname]
        print('self.meshlist_all:',self.meshlist_all)
        #self._updateMeshList()
        self.file_name, self.nom_med = self.get_cmd_mesh(self.meshlist_all[0])
        #self.fname, self.nom_med = self.get_cmd_mesh(self.meshlist_all[0])
        print('file_name:',self.file_name)
        print('nom_med:',type(self.nom_med))
        self.meshFileChanged.emit(self.file_name, self.nom_med, 1.0, True)

        grtype = MeshGroupType.GElement
        all_groups = get_medfile_groups(self.file_name, None, grtype)
        self.mesh_group = all_groups
        print('all_groups:',all_groups)
        # 优化设计域
        # self.ui.comboBox.addItems(self.mesh_group)
        #self.meshview.displayAllGroups(self.file_name, self.nom_med)
        # medname = 'change_mesh.sh'
        # #medname = 'Mesh_1.med'
        # meddir = os.path.join(self.curr_dir,medname)
        # print('meddir:',meddir)
        # #cmd = 'sh ' + meddir + ' ' + fname 
        # cmd = meddir + ' ' + fname 
        # #cmd1 = 'rm -f ' + meddir
        # #cmd2 = 'cp -f ' + fname + ' ' + meddir
        # QApplication.processEvents()
        # self.process.start(cmd)
        # self.process.waitForFinished()
        # self.process.start(cmd1)
        # self.process.start(cmd2)
        # print('cmd:',cmd)
                
        # subprocess.Popen(cmd2, shell=True)
        #     #self.highlight_beams()
        #self._highlight_mesh_group()

    def highlight_node(self,name):
        """"""
        grtype = MeshGroupType.GNode
        all_groups = get_medfile_groups(self.file_name, None, grtype)
        print('all_groups:',all_groups)
        var = name
        print("var:",var)
        rgb = [0,1,0.333333]

        for g in all_groups:
            self.meshGroupUnCheck.emit(self.file_name,
                                        self.nom_med,
                                        g,
                                        MeshGroupType.GNode)

        self.meshGroupCheckColor.emit(self.file_name,
                                        self.nom_med,
                                        var,
                                        MeshGroupType.GNode,
                                        rgb)

    def highlight_elem(self,name):
        """"""
        grtype = MeshGroupType.GElement
        all_groups = get_medfile_groups(self.file_name, None, grtype)
        print('all_groups:',all_groups)
        var = name
        print("var:",var)
        rgb = [0,1,0.333333]

        for g in all_groups:
            self.meshGroupUnCheck.emit(self.file_name,
                                        self.nom_med,
                                        g,
                                        MeshGroupType.GElement)

        self.meshGroupCheckColor.emit(self.file_name,
                                        self.nom_med,
                                        var,
                                        MeshGroupType.GElement,
                                        rgb)
    def highlight_beams(self):
        """"""
        beam_list=['road','main_beams','lateral_beams','top_beams','bottom_beams']
        rgb_list = [[1,0,0.498039],[0,0.333333,1],[0,1,0.333333],[1,1,0],[1,1,0]]
        index = self.ui.tabWidget_2.currentIndex()
        print('index:',index)
        var = beam_list[index]
        rgb = rgb_list[index]
        #if index !=0:
         #   self.beamsectionChanged.emit()
        grtype = MeshGroupType.GElement
        all_groups = get_medfile_groups(self.file_name, None, grtype)
        print('all_groups:',all_groups)
        for g in all_groups:
            self.meshGroupUnCheck.emit(self.file_name,
                                        self.nom_med,
                                        g,
                                        MeshGroupType.GElement)

        self.meshGroupCheckColor.emit(self.file_name,
                                        self.nom_med,
                                        var,
                                        MeshGroupType.GElement,
                                        rgb)

         #if typ in ('groups_ma',) else MeshGroupType.GNode
        
        #for var in all_groups:
        #self.meshGroupUnCheck.emit(file_name,
         #                           nom_med,
          #                          var,
           #                         self._meshGroupType(),)

    def _meshGroupType(self):
        """
        Get the type of the mesh group

        Returns:
            str: Mesh group type (see `MeshGroupType`).
        """
        #mgtype = -1
        #mgtype = MeshGroupType.GElement
        if self.qiehuan == 1:
            mgtype = MeshGroupType.GNode
        else:
            mgtype = MeshGroupType.GElement
        #kw_def = self.keyword().definition
        #typ = kw_def.get('typ')
        #if isinstance(typ, (tuple, list)):
        #    typ = typ[0] if typ else None
        #if is_subclass(typ, CATA.package('DataStructure').grma):
        #    mgtype = MeshGroupType.GElement
        #elif is_subclass(typ, CATA.package('DataStructure').grno):
        #    mgtype = MeshGroupType.GNode
        return mgtype

    def _updateMeshList(self):
        """
        Updates the mesh list in the combobox
        针对Tanksimulator固体(流体TODO)前处理进行了重写 Daizijian 2019/11/26
        """
        #mlist_cur = avail_meshes(parameterPanel(self).pendingStorage())
        #mlist_cmd = avail_meshes(parameterPanel(self).pendingCommandStorage())
        #mlist_cmd = [m for m in mlist_cmd if m not in mlist_cur]
        #meshlist = mlist_cur + mlist_cmd
        #meshlist.reverse()
        # self._loade

        meshlist=self.meshlist_all
        #self.setMeshList(meshlist)
        msg = ""
        if len(meshlist) >= 1:
            #msg = translate("ParameterPanel", "More than one mesh found")
            #msg = "当前已存储了"+str(len(meshlist))+"个网格"
            msg = "当前上传数"+str(len(meshlist))
        elif not meshlist:
            #msg = translate("ParameterPanel", "No mesh found")
            msg = "当前没有网格"
        #self.setMessage(msg)
        self._meshActivated()

    def _meshActivated(self):
        """
        Updates the mesh groups in checkable list.
        Invoked after mesh changing in mesh combobox.
        """
        meshcmd=self.meshlist_all[0]        
        print('meshcmd', meshcmd)
        print('get_medfile_meshes(meshcmd):',get_medfile_meshes(meshcmd))
        groups = {}
        if meshcmd is not None:
            group_type = self._meshGroupType()
            file_name, nom_med = self.get_cmd_mesh(meshcmd)
            if is_medfile(file_name) or is_reference(file_name):
                self.meshFileChanged.emit(file_name, nom_med, 0.1, False)
                self.minmax6 = self.meshview.getBounding6(file_name,nom_med)
                print('self.minmax6',self.minmax6)

            groups = self.get_cmd_groups(file_name,group_type)
            print('groups:',groups)
        self.meshChanged.emit()

    def _meshGroupType(self):
        """
        Get the type of the mesh group

        Returns:
            str: Mesh group type (see `MeshGroupType`).
        """
        #mgtype = -1
        #mgtype = MeshGroupType.GElement
        if self.qiehuan == 1:
            mgtype = MeshGroupType.GNode
        else:
            mgtype = MeshGroupType.GElement
        return mgtype

    def get_cmd_groups(self,meshcmd, group_type): #重写，顶掉原来的定义   
        #pass
        #定义是 def get_medfile_groups(mesh_file, mesh_name, group_type):
        #return get_medfile_groups(meshcmd, get_medfile_meshes(meshcmd)[0], group_type)
        #return get_medfile_groups(meshcmd, get_medfile_meshes(meshcmd), group_type)
        groups={}
        elem_types = MeshElemType.elem_types(group_type)
        file_name = meshcmd
        nom_med = get_medfile_meshes(meshcmd)[0]
        for elem_type in elem_types:
            elem_groups = get_medfile_groups_by_type(file_name, nom_med,
                                                        elem_type, True)
            groups[elem_type] = elem_groups
        return groups

    def get_cmd_mesh(self,meshcmd):   #重写，顶掉原来的定义   
        # print("get_medfile_meshes返回内容为：",get_medfile_meshes(meshcmd))
        if len(get_medfile_meshes(meshcmd))>1:
            return meshcmd, get_medfile_meshes(meshcmd)[0] # 例如。example.med 取为 example
        elif len(get_medfile_meshes(meshcmd))==1:
            return meshcmd, get_medfile_meshes(meshcmd)[0]

    def change_bridge(self,fdir):
        data = ''
        with open(fdir, 'r+') as f:
            for line in f.readlines():
                if(line.find('width') == 0):
                    line = 'width = %s' % (str(self.width1)) + '\n'
                if(line.find('height') == 0):
                    line = 'height = %s' % (str(self.height1)) + '\n'
                if(line.find('length') == 0):
                    line = 'length = %s' % (str(self.length)) + '\n'
                if(line.find('sections') == 0):
                    line = 'sections = %s' % (str(self.sections)) + '\n'
                data += line
        with open(fdir, 'r+') as f:
            f.writelines(data)

    def check_iseven(self,num):
        s=str(float(num)).split('.')
        if float(s[1])==0:
            print('整数')
            if (int(num) % 2 == 0):
                return True
            else:
                QtWidgets.QMessageBox.information(self, '错误', '节点数必须是偶数!')
                return False
        else :
            print('小数')
            QtWidgets.QMessageBox.information(self, '错误', '节点数必须是偶数!')
            return False

    def cal_spacing(self):
        self.width1 = self.ui.width_lineEdit.text()
        self.length = self.ui.length_lineEdit.text()
        self.height1 = self.ui.height_lineEdit.text()
        self.sections = self.ui.sections_lineEdit.text()
        self.spacing = self.ui.spacing_lineEdit.text() 
        parameters=[self.width1,self.length,self.height1,self.sections]
        for i in parameters:
            print('i:',i)
            self.check_parameter_isnum(i)
        #self.check_iseven(self.sections)
        self.width1 = float('%.2f' % float(self.ui.width_lineEdit.text()))
        self.length = float('%.2f' % float(self.ui.length_lineEdit.text()))
        self.height1 = float('%.2f' % float(self.ui.height_lineEdit.text()))
        self.sections = int(self.ui.sections_lineEdit.text())
        self.spacing = float('%.2f' % float((self.length/self.sections)))
        self.ui.spacing_lineEdit.setText(str(self.spacing))

        parameters=[self.width1,self.height1,self.length,self.sections,self.spacing]

        fname = 'Mesh' #网格文件
        for i in parameters:
            fname = fname + '_' + str(i)
        fname = fname + '.med'
        self.fname = fname
        script_name = 'create_geo_mesh_new.py' #参数化脚本
        fdir = os.path.join(self.work_dir,fname)
        self.fdir_curr = os.path.join(self.curr_dir,fname)
        script_dir = os.path.join(self.work_dir,script_name)
        script_dir_curr = os.path.join(self.curr_dir,script_name)
        self.change_bridge(script_dir)
        time.sleep(0.25)
        try:
            if(self.check_iseven(self.sections)):
                exec(open(script_dir,"rb").read())
                self.process.start('echo 运行参数化建模脚本中')
        except:
            print("脚本错误!")
            self.process.start('echo 脚本错误！')
        #exec(open('/amd_share/online1/install/truss_bridge/script/create_geo_mesh.py').read())
        #self.show_mesh_1(fdir_curr)
        self.startmesh(self.fdir_curr)

    def reset(self):
        self.ui.width_lineEdit.setText('8')
        self.ui.length_lineEdit.setText('40')
        self.ui.height_lineEdit.setText('5')
        self.ui.sections_lineEdit.setText('8')
        self.ui.spacing_lineEdit.setText('5')
        self.cal_spacing()

    def show_mesh_1(self,fdir):
        '''
            显示网格
        '''
        #boundary_file = self.workingdirectory + '/constant/polyMesh/boundary'
        try:
            if self.currentdisplay:
                current_display = pvs.GetActiveSource()
                pvs.Delete(current_display)
                print('delete ok')
                self.process.start('echo 清除当前显示')
                self.process.waitForFinished()
        except Exception as e:
            print(e)
        try:
            self.warpByVector1Display.SetScalarBarVisibility(self.renderView1, False)
            self.static_resrmedDisplay.SetScalarBarVisibility(self.renderView1, False)
            self.process.start('echo 清除图例')
        except:
            self.process.start('echo 无前置图例...')
            self.process.waitForFinished()
        finally:
            self.process.start('echo 开始显示网格...')
            self.process.waitForFinished()
            #self.show_mesh_display_list(boundary_file)
            self.res = pvs.MEDReader(FileName=fdir)
            self.ren_view = pvs.GetRenderView()
            self.foamDisplay =pvs.Show(self.res, self.ren_view)
            #self.foamDisplay.SetRepresentationType('Surface With Edges')
            self.currentdisplay = self.foamDisplay
            # The following two lines insure that the view is refreshed
            #self.pv_splitter.setVisible(False)
            #self.pv_splitter.setVisible(True)
            self.process.start('echo 网格已显示')
            self.process.waitForFinished()

    def create_static_comm(self,material1,material2,element,curr_dir,pres):
        #file = work_dir + '/static.comm'
        fname = 'static.comm'
        file = os.path.join(curr_dir,fname)
        print('file:',file)
        data = ''
        i = 1
        with open(file,'r+') as f:
            for line in f.readlines():
                if(line.find('steel') == 0):
                    #line = 'width = %s' % (str(self.width1)) + '\n'
                    line = 'steel = DEFI_MATERIAU(ELAS=_F(E=%s, NU=%s, RHO=%s))' % (material1[0],material1[1],material1[2])  + '\n'
                if(line.find('concrete') == 0):
                    line = 'concrete = DEFI_MATERIAU(ELAS=_F(E=%s, NU=%s, RHO=%s))' % (material2[0],material2[1],material2[2])  + '\n'
                '''print(i,len(line))
                if(line.find('CARA',4) == 0):
                    print('ok')'''
                if i == 23:
                    line = '    COQUE=_F(EPAIS=%s, GROUP_MA=(\'road\', )),' % (element[0]) + '\n'
                if i == 30:
                    line = '            VALE=(%s, )' % (element[1]) + '\n'
                if i == 35:
                    line = '            VALE=(%s, )' % (element[2]) + '\n'
                if i == 40:
                    line = '            VALE=(%s, )' % (element[3]) + '\n'
                if i == 45:
                    line = '            VALE=(%s, )' % (element[4]) + '\n'
                if i == 67:
                    line = '    PRES_REP=_F(GROUP_MA=(\'road\', ), PRES=%s)' % (pres) + '\n'
                i+=1
                data += line
        f.close
        #print(data)
        with open(file,'r+') as f:
            f.writelines(data)
        f.close

    def create_modes_comm(self,material1,material2,element,curr_dir,fre):
        fname = 'modes.comm'
        file = os.path.join(curr_dir,fname)
        print('file:',file)
        data = ''
        i = 1
        with open(file,'r+') as f:
            for line in f.readlines():
                if(line.find('steel') == 0):
                    #line = 'width = %s' % (str(self.width1)) + '\n'
                    line = 'steel = DEFI_MATERIAU(ELAS=_F(E=%s, NU=%s, RHO=%s))' % (material1[0],material1[1],material1[2])  + '\n'
                if(line.find('concrete') == 0):
                    line = 'concrete = DEFI_MATERIAU(ELAS=_F(E=%s, NU=%s, RHO=%s))' % (material2[0],material2[1],material2[2])  + '\n'

                if i == 18:
                    line = '    COQUE=_F(EPAIS=%s, GROUP_MA=(\'road\', )),' % (element[0]) + '\n'
                if i == 25:
                    line = '            VALE=(%s, )' % (element[1]) + '\n'
                if i == 30:
                    line = '            VALE=(%s, )' % (element[2]) + '\n'
                if i == 35:
                    line = '            VALE=(%s, )' % (element[3]) + '\n'
                if i == 40:
                    line = '            VALE=(%s, )' % (element[4]) + '\n'
                if i == 78:
                    line = '    CALC_FREQ=_F(NMAX_FREQ=%s),' % (fre) + '\n'

                i+=1
                data += line
        f.close
        with open(file,'r+') as f:
            f.writelines(data)
        f.close

    def change_element_pro(self):
        #from .create_static_comm import create_static_comm
        #fname = 'static.comm' #网格文件
        #fdir_curr = os.path.join(self.curr_dir,fname)
        element0 = self.ui.tab0_H_value.text()
        element1 = self.ui.tab1_H_value.text()
        element2 = self.ui.tab2_H_value.text()
        element3 = self.ui.tab3_H_value.text()
        element4 = self.ui.tab4_H_value.text()
        self.element = [element0,element1,element2,element3,element4]

        material11 = self.ui.modulus_value_beams.text()
        material12 = self.ui.poisson_value_beams.text()
        material13 = self.ui.rho_value_beams.text()
        self.material1 = [material11,material12,material13]

        material21 = self.ui.modulus_value_road.text()
        material22 = self.ui.poisson_value_road.text()
        material23 = self.ui.rho_value_road.text()
        self.material2 = [material21,material22,material23]
        for i in self.element + self.material1 + self.material2:
            self.check_parameter_isnum(i)
        try:
            self.create_static_comm(self.material1,self.material2,self.element,self.curr_dir,'1e5')
            self.create_modes_comm(self.material1,self.material2,self.element,self.curr_dir,'10')
            #material1=[2e11,0.3,7850]
            #material2=[2.5e10,0.2,2500]
            #element = [0.1,0.2,0.3,0.4,0.5]
            print('curr_dir:',self.curr_dir_2)
            #self.create_static_comm(material1,material2,element,self.curr_dir_2)
            self.process.start('echo 写入comm文件中')

        except:
            self.process.start('echo 写入comm文件失败')
        
    def submit(self):
        if self.ui.modes_button.isChecked():
            self.fre,ok = QtWidgets.QInputDialog.getText(self,'设置所需模态阶数','请输入阶数：')
            print('set fre = ',self.fre)
            fname = 'fre.set'
            file = os.path.join(self.curr_dir,fname)
            with open(file,'w+') as f:
                f.writelines(self.fre)
            f.close

            while ok and self.check_parameter_isnum(self.fre) and self.check_parameter_isint(self.fre):
                self.create_modes_comm(self.material1,self.material2,self.element,self.curr_dir,self.fre)
                self.disable_some_buttons()
                self.ui.pushButton_4.setEnabled(False)
                #cmd = '/amd_share/online1/install/code_aster_14.6/14.6/bin/as_run '
                cmd = 'sh '
                cmd += self.curr_dir
                cmd += '/submit2.sh'
                print('cmd_modes:',cmd)
                try:
                    self.process2.start('echo 提交计算')
                    QApplication.processEvents()
                    self.process.start(cmd)
                    #self.process.waitForFinished()
                    QtWidgets.QMessageBox.information(self, '提示', '已提交计算，请稍等!')
                    self.ui.pushButton_4.setEnabled(False)
                    time.sleep(8)
                    self.ui.pushButton_break.setEnabled(True)
                    self.enable_some_buttons()
                    ok = 0
                except:
                    self.process2.start('echo 提交计算失败') 
                    ok = 0           
        else:
            self.pres,ok = QtWidgets.QInputDialog.getText(self,'设置压力','请输入压力/Pa：')
            #cmd = '/amd_share/online1/install/code_aster_14.6/14.6/bin/as_run '
            while ok and self.check_parameter_isnum(self.pres):
                self.disable_some_buttons()
                self.ui.pushButton_4.setEnabled(False)
                self.create_static_comm(self.material1,self.material2,self.element,self.curr_dir,self.pres)    
                cmd = 'sh '
                cmd += self.curr_dir
                cmd += '/submit.sh'
                print('cmd:',cmd)
                try:
                    self.process2.start('echo 提交计算')
                    print('提交计算！')
                    QApplication.processEvents()
                    self.process.start(cmd)
                    self.process.waitForFinished()
                    QtWidgets.QMessageBox.information(self, '提示', '已提交计算，请稍等!')
                    self.ui.pushButton_4.setEnabled(False)
                    time.sleep(8)
                    self.ui.pushButton_break.setEnabled(True)
                    self.enable_some_buttons()
                    ok = 0
                except:
                    self.process2.start('echo 提交计算失败')
                    print('提交计算失败!')
                    ok = 0
    
    def check_parameter_isnum(self,num):
        try:
            num = float(num)
            s=str(num).split('.')
            if float(s[1])==0:
                print('整数')
                return True
            else :
                print('小数')
                return True
        except:
            print("输入的不是数字!")
            QtWidgets.QMessageBox.information(self, '错误', '请输入数字!')
            return False

    def check_parameter_isint(self,num):
        num = float(num)
        s=str(num).split('.')
        if float(s[1])==0:
            print('整数')
            return True
        else :
            print('小数')
            QtWidgets.QMessageBox.information(self, '错误', '请输入整数!')
            return False       

    def show_modes_result(self):
        #choice = self.fre[0]
        choice_list = self.fre_all
        #QInputDialog.getItem(self, "select input dialog", '语言列表', items, 0, False)
        self.fre_show, ok = QtWidgets.QInputDialog.getItem(self, "select", '阶数', choice_list, 0, False)
        index_id = choice_list.index(self.fre_show)
        print('index_id:',index_id)
        if ok:
            try:
                if self.currentdisplay:
                    current_display = pvs.GetActiveSource()
                    pvs.Delete(current_display)
                    print('delete ok')
                    self.process.start('echo 清除当前显示')
                    self.process.waitForFinished()
                    
            except Exception as e:
                print('show_modes_result error!')
            try:
                self.warpByVector1Display.SetScalarBarVisibility(self.renderView1, False)
                self.static_resrmedDisplay.SetScalarBarVisibility(self.renderView1, False)
                self.process.start('echo 清除图例')
            except:
                self.process.start('echo 无前置图例...')
                self.process.waitForFinished()
            finally:
                fname = 'study_modes.rmed'
                fdir = os.path.join(self.curr_dir,fname)
                self.process.start('echo 开始显示模态分析结果...')
                self.process.waitForFinished()
                self.modes_resrmed = pvs.MEDReader(FileName=fdir)
                animationScene1 = pvs.GetAnimationScene()
                self.modes_resrmed.GenerateVectors = 1
                self.modes_resrmed.ActivateMode = 1
                renderView1 = pvs.GetActiveViewOrCreate('RenderView')
                modes_resrmedDisplay = pvs.Show(self.modes_resrmed, renderView1)
                modes_resrmedDisplay.Representation = 'Surface'
                renderView1.ResetCamera()
                materialLibrary1 = pvs.GetMaterialLibrary()
                animationScene1.UpdateAnimationUsingDataTimeSteps()
                renderView1.Update()

                pvs.Hide(self.modes_resrmed, renderView1)
                self.warpByVector2 = pvs.WarpByVector(Input=self.modes_resrmed)
                self.warpByVector2.ScaleFactor = 3.0
                pvs.SetActiveSource(self.warpByVector2)
                self.warpByVector2Display = pvs.Show(self.warpByVector2, renderView1)
                renderView1.Update()
                self.warpByVector2Display.Representation = 'Surface'
                self.warpByVector2.Vectors = ['POINTS', 'unnamed0DEPL [%s] - %s_Vector' %(index_id,self.fre_show[0:7])]
                pvs.ColorBy(self.warpByVector2Display, ('POINTS', 'unnamed0DEPL [%s] - %s' %(index_id,self.fre_show[0:7]), 'Magnitude'))
                self.warpByVector2Display.RescaleTransferFunctionToDataRange(True, False)
                self.warpByVector2Display.SetScalarBarVisibility(renderView1, False)
                renderView1.Update()
                self.currentdisplay = self.warpByVector2
                # The following two lines insure that the view is refreshed
                self.pv_splitter.setVisible(False)
                self.pv_splitter.setVisible(True)
                self.process.start('echo 网格已显示')
                self.process.waitForFinished()
                self.ui.pushButton_4.setEnabled(True)
        
    def read_fre(self):
        file = self.curr_dir + '/modes.mess'
        num = int(self.fre)
        print('num:',num)
        data = ''
        i = 1
        id_modal = 0
        with open(file,'r+') as f:
            for line in f.readlines():
                if(line.find('     Calcul modal') == 0):
                    #line = 'width = %s' % (str(self.width1)) + '\n'
                    print('modal:',i)
                    id_modal = i
                if i >= (id_modal + 4) and i <= (id_modal + 4 + num -1) and id_modal:
                    data +=line
                i+=1
        f.close
        '''try:
            with open(file,'r+') as f:
                for line in f.readlines():
                    if(line.find('     Calcul modal') == 0):
                        #line = 'width = %s' % (str(self.width1)) + '\n'
                        print('modal:',i)
                        id_modal = i
                    if i >= (id_modal + 4) and i <= (id_modal + 4 + num -1) and id_modal:
                        data +=line
                    i+=1
            f.close
        except:
            print('error! Not find frequency result!')
                #data += line'''
        
        print('id_modal:',id_modal)
        print(data.split())
        fre_data = data.split()
        self.fre_all = []
        for i in range(1,len(fre_data),3):
            #print(fre_data[i])
            self.fre_all.append(fre_data[i])
        print('fre:',self.fre_all)
        self.fre_num = []
        for i in self.fre_all:
            j = i[0:7]
            self.fre_num.append(j)
        print('fre_num:',self.fre_num)

    def select_modes(self):
        #choice = self.fre[0]
        choice_list = self.fre_all
        #QInputDialog.getItem(self, "select input dialog", '语言列表', items, 0, False)
        self.fre_show, ok = QtWidgets.QInputDialog.getItem(self, "select", '阶数', choice_list, 0, False)

    def show_result(self):
        if self.ui.modes_button.isChecked():
            try:
                self.read_fre() # 读取模态结果
            except:
                QtWidgets.QMessageBox.information(self, '提示', '您还没有计算模态!')
            time.sleep(0.5)
            self.show_modes_result()
        else:
            self.show_static_result()

    def show_static_result(self):
        choice_list = ['位移','应力']
        self.res_show, ok = QtWidgets.QInputDialog.getItem(self, "select", '结果类型', choice_list, 0, False)
        try:
            if self.currentdisplay:
                current_display = pvs.GetActiveSource()
                pvs.Delete(current_display)
                print('delete ok')
                self.process.start('echo 清除当前显示')
                self.process.waitForFinished()
        except Exception as e:
                print(e)
        if self.res_show == '位移' and ok:
            fname = 'static_res.rmed'
            fdir = os.path.join(self.curr_dir,fname)
            self.process.start('echo 开始显示静力学结果...')
            self.process.waitForFinished()
            self.static_resrmed = pvs.MEDReader(FileName=fdir)
            self.static_resrmed.AllArrays = ['TS0/mesh/ComSup0/reslin__DEPL@@][@@P1']
            self.static_resrmed.GenerateVectors = 1
            self.renderView1 = pvs.GetActiveViewOrCreate('RenderView')
            static_resrmedDisplay = pvs.Show(self.static_resrmed, self.renderView1)
            static_resrmedDisplay.Representation = 'Surface'
            self.renderView1.ResetCamera()
            materialLibrary1 = pvs.GetMaterialLibrary()
            self.renderView1.Update()
            # set scalar coloring
            pvs.ColorBy(static_resrmedDisplay, ('POINTS', 'reslin__DEPL_Vector', 'Magnitude'))
            # rescale color and/or opacity maps used to include current data range
            static_resrmedDisplay.RescaleTransferFunctionToDataRange(True, False)
            # show color bar/color legend
            static_resrmedDisplay.SetScalarBarVisibility(self.renderView1, True)
            # get color transfer function/color map for 'reslin__DEPL_Vector'
            reslin__DEPL_VectorLUT = pvs.GetColorTransferFunction('reslin__DEPL_Vector')
            # get opacity transfer function/opacity map for 'reslin__DEPL_Vector'
            reslin__DEPL_VectorPWF = pvs.GetOpacityTransferFunction('reslin__DEPL_Vector')
            # create a new 'Warp By Vector'
            self.warpByVector1 = pvs.WarpByVector(Input=self.static_resrmed)
            # set active source
            pvs.SetActiveSource(self.warpByVector1)
            # show data in view
            self.warpByVector1Display = pvs.Show(self.warpByVector1, self.renderView1)
            # trace defaults for the display properties.
            self.warpByVector1Display.Representation = 'Surface'
            # show color bar/color legend
            self.warpByVector1Display.SetScalarBarVisibility(self.renderView1, True)
            # show data in view
            self.warpByVector1Display = pvs.Show(self.warpByVector1, self.renderView1)
            # hide data in view
            pvs.Hide(self.static_resrmed, self.renderView1)
            # show color bar/color legend
            self.warpByVector1Display.SetScalarBarVisibility(self.renderView1, True)
            # update the view to ensure updated data information
            self.renderView1.Update()
            self.currentdisplay = self.warpByVector1
            # The following two lines insure that the view is refreshed
            self.pv_splitter.setVisible(False)
            self.pv_splitter.setVisible(True)
            self.process.start('echo 网格已显示')
            self.process.waitForFinished()
            self.ui.pushButton_4.setEnabled(True)
        if self.res_show == '应力' and ok:
            fname = 'static_res.rmed'
            fdir = os.path.join(self.curr_dir,fname)
            self.process.start('echo 开始显示静力学结果...')
            self.process.waitForFinished()
            self.static_resrmed = pvs.MEDReader(FileName=fdir)
            self.renderView1 = pvs.GetActiveViewOrCreate('RenderView')
            self.static_resrmedDisplay = pvs.Show(self.static_resrmed, self.renderView1)
            self.static_resrmedDisplay.Representation = 'Surface'
            pvs.ColorBy(self.static_resrmedDisplay, ('POINTS', 'reslin__EFGE_NOEU', 'Magnitude'))
            self.static_resrmedDisplay.RescaleTransferFunctionToDataRange(True, False)
            self.static_resrmedDisplay.SetScalarBarVisibility(self.renderView1, True)
            self.renderView1.Update()
            self.currentdisplay = self.warpByVector1
            # The following two lines insure that the view is refreshed
            self.pv_splitter.setVisible(False)
            self.pv_splitter.setVisible(True)
            self.process.start('echo 网格已显示')
            self.process.waitForFinished()
            self.ui.pushButton_4.setEnabled(True)

    def init_paraview(self, full_load_pv=True):
        """
        Initializes, if necessary, paraview and creates a dedicated pvsimple
        view in the results tab.
        """
        from ..salomegui import (get_salome_pyqt, get_salome_gui)

        if not self.pv_view:
            import time
            #dbg_print(">> Initializing PV view for the main tab...")
            start = time.time()
            self.views = get_salome_pyqt().findViews('ParaView')
            self.pv_view = self.views[-1]
            get_salome_pyqt().activateViewManagerAndView(self.pv_view)
            paraview = self.update_pv_layout_view()
            end = time.time()
            #dbg_print("  Finished in %d seconds..." % int(end - start))

            self._finalize_pv_widget()
        else:
            self.update_pv_layout_view()
            self._finalize_pv_widget()

        if self.current:
            self.redraw()

    def _finalize_pv_widget(self):
        """
        References toolbuttons (for interactive selection) and updates the
        overlay widget if needed
        """
        if self.pv_widget:
            if not self.toolbuttons:
                self._add_toolbuttons()
            if not self.pv_overlay:
                self._add_overlay()

    def _add_toolbuttons(self):
        """
        Shortcut for referencing the toolbuttons that may need to be
        automatically activated for point and cell selections

        requires : self.pv_widget
        """
        self.toolbuttons = {'Interactive Select Cells On': None,
                            'Interactive Select Points On': None,
                            'Select Points On (d)': None,
                            'Select Cells On (s)': None,
                            }
        to_find = list(self.toolbuttons.keys())

        for tbutt in self.pv_widget.findChildren(QtWidgets.QToolButton)[::-1]:
            if not to_find:
                break
            for tooltip in to_find:
                if tooltip in tbutt.toolTip():
                    self.toolbuttons[tooltip] = tbutt
                    to_find.remove(tooltip)
                    break

    def update_pv_layout_view(self, full_update=True):
        """
        Updates or creates a new PV layout and view for AsterStudy
        post processing in the Results tab
        """
        import pvsimple as pvs
        from ..salomegui import get_salome_pyqt

        pv_layout = pvs.GetLayoutByName(RESULTS_PV_LAYOUT_NAME)
        if not pv_layout:
            pv_layout = pvs.CreateLayout(name=RESULTS_PV_LAYOUT_NAME)

            
        self.views = pvs.GetViewsInLayout(pv_layout)
        if not self.views:
            pvs.SetActiveView(None)
            self.ren_view = pvs.CreateRenderView(guiName=RESULTS_PV_VIEW_NAME)

            self.ren_view.UseGradientBackground = 1
            pv_layout.AssignView(0, self.ren_view)

        self.pv_layout = pvs.GetLayoutByName("Layout #1")

        self.pv_widget = get_salome_pyqt().getViewWidget(self.pv_view)
        self.pv_widget.setSizePolicy(QtWidgets.QSizePolicy.Expanding,
                                    QtWidgets.QSizePolicy.Expanding)

        self.pv_splitter.addWidget(self.pv_widget)

        self.pv_splitter.setVisible(False)
        self.pv_splitter.setVisible(True)

        pvs.Render()

        self.pv_widget_children = [self.pv_widget]
        self.pv_widget_children += self.pv_widget.findChildren(QtWidgets.QWidget)

        to_ignore = []
        if self.pv_overlay:
            to_ignore = [self.pv_overlay] + \
                self.pv_overlay.findChildren(QtWidgets.QWidget)

        for child in self.pv_widget_children:
            if not child in to_ignore:
                child.installEventFilter(self)
    
    def enable_some_buttons(self):
        '''
            让一些按钮生效或失效，以防用户误操作
        '''
        self.ui.pushButton_ok.setEnabled(True)
        self.ui.pushButton_reset.setEnabled(True)
        self.ui.pushButton_beam.setEnabled(True)
        self.ui.apply.setEnabled(True)
        self.ui.static_button.setEnabled(True)
        self.ui.modes_button.setEnabled(True)
        self.ui.pushButton_4.setEnabled(True)

    def disable_some_buttons(self):
        '''
            让一些按钮生效或失效，以防用户误操作
        '''
        self.ui.pushButton_ok.setEnabled(False)
        self.ui.pushButton_reset.setEnabled(False)
        self.ui.pushButton_beam.setEnabled(False)
        self.ui.apply.setEnabled(False)
        self.ui.static_button.setEnabled(False)
        self.ui.modes_button.setEnabled(False)
        self.ui.pushButton_break.setEnabled(False)

    @Q.pyqtSlot()
    def _addRow(self):
        """Insert new row to table."""
        #row = self.table.rowCount()
        row = self.ui.tableWidget.rowCount()
        #row = row + 1
        #self.table.insertRow(row)
        #self.table.insertRow(row+1)
        # button = GroupsButton(self)
        # button.mesh = self.mesh()
        # button.typ = "groups_no"#attributes.get('typ')
        # #button.value = default_value(attributes)
        # button.value = ""
        # connect(button.clicked, self._selectGroupsEdit)
        #self.table.setRowCount(row + 1)
        self.ui.tableWidget.setRowCount(row + 1)
        self.mesh_group_combo = Q.QComboBox()
        self.mesh_group_combo.addItems(self.mesh_group)
        # ckbox1=Q.QCheckBox()
        # ckbox2=Q.QCheckBox()
        ckbox3=Q.QCheckBox()
        line1 = Q.QLineEdit()
        line2 = Q.QLineEdit()
        line3 = Q.QLineEdit()
        self.ui.tableWidget.setCellWidget(row,0,self.mesh_group_combo)
        self.ui.tableWidget.setCellWidget(row,1,line1)
        self.ui.tableWidget.setCellWidget(row,2,line2)
        self.ui.tableWidget.setCellWidget(row,3,line3)

    @Q.pyqtSlot()
    def _removeSelectedRow(self):
        """Remove selected row(s)."""
        selected = self.ui.tableWidget.selectedItems()
        rows = sorted(set([i.row() for i in selected] + [self.ui.tableWidget.currentRow()]), reverse=True)
        for row in rows:
            self.ui.tableWidget.removeRow(row)

    @Q.pyqtSlot()
    def _addRow_2(self):
        """Insert new row to table."""
        #row = self.table.rowCount()
        row = self.ui.tableWidget_2.rowCount()
        #row = row + 1
        #self.table.insertRow(row)
        #self.table.insertRow(row+1)
        # button = GroupsButton(self)
        # button.mesh = self.mesh()
        # button.typ = "groups_no"#attributes.get('typ')
        # #button.value = default_value(attributes)
        # button.value = ""
        # connect(button.clicked, self._selectGroupsEdit)
        #self.table.setRowCount(row + 1)
        self.ui.tableWidget_2.setRowCount(row + 1)
        self.mesh_group_combo = Q.QComboBox()
        self.mesh_group_combo.addItems(self.mesh_group)
        line1 = Q.QLineEdit()
        line2 = Q.QLineEdit()
        line3 = Q.QLineEdit()
        self.ui.tableWidget_2.setCellWidget(row,0,self.mesh_group_combo)
        self.ui.tableWidget_2.setCellWidget(row,1,line1)
        self.ui.tableWidget_2.setCellWidget(row,2,line2)
        self.ui.tableWidget_2.setCellWidget(row,3,line3)

    @Q.pyqtSlot()
    def _removeSelectedRow_2(self):
        """Remove selected row(s)."""
        selected = self.ui.tableWidget_2.selectedItems()
        rows = sorted(set([i.row() for i in selected] + [self.ui.tableWidget_2.currentRow()]), reverse=True)
        for row in rows:
            self.ui.tableWidget_2.removeRow(row)
    @Q.pyqtSlot()
    def _addRow_3(self):
        """Insert new row to table."""
        #row = self.table.rowCount()
        row = self.ui.tableWidget_3.rowCount()
        #row = row + 1
        #self.table.insertRow(row)
        #self.table.insertRow(row+1)
        # button = GroupsButton(self)
        # button.mesh = self.mesh()
        # button.typ = "groups_no"#attributes.get('typ')
        # #button.value = default_value(attributes)
        # button.value = ""
        # connect(button.clicked, self._selectGroupsEdit)
        #self.table.setRowCount(row + 1)
        self.ui.tableWidget_3.setRowCount(row + 1)
        self.mesh_group_combo = Q.QComboBox()
        self.mesh_group_combo.addItems(self.mesh_group)
        Constraint = ["MASS","EIGENFREQUENCY","STRAIN ENERGY","STRESS"]
        Method = ["<=相对值",">=相对值","=相对值","=绝对值"]
        Combo1 = Q.QComboBox()
        Combo1.addItems(Constraint)
        Combo2 = Q.QComboBox()
        Combo2.addItems(Method)
        line1 = Q.QLineEdit()
        #line3 = Q.QLineEdit()
        self.ui.tableWidget_3.setCellWidget(row,0,Combo1)
        self.ui.tableWidget_3.setCellWidget(row,1,Combo2)
        self.ui.tableWidget_3.setCellWidget(row,2,line1)
        #self.ui.tableWidget_2.setCellWidget(row,3,line3)

    @Q.pyqtSlot()
    def _removeSelectedRow_3(self):
        """Remove selected row(s)."""
        selected = self.ui.tableWidget_3.selectedItems()
        rows = sorted(set([i.row() for i in selected] + [self.ui.tableWidget_3.currentRow()]), reverse=True)
        for row in rows:
            self.ui.tableWidget_3.removeRow(row)

    # @Q.pyqtSlot()
    # def _editingRow(self):
    #     """Remove selected row(s)."""
    #     edit = self.ui.tableWidget.editTriggers()
    #     rows = edit
    #     print("rows:",rows)
    def current_combo_text(self):
        # selected = self.ui.tableWidget.selectedItems()
        # row = [self.ui.tableWidget.currentRow()]
        # row = int(row[0])
        # #rows = sorted(set([i.row() for i in selected] + [self.MyTable.currentRow()]), reverse=True)
        # print("row:",row)
        # #if (int(row[0]) != 0):
        # combo_content = self.ui.tableWidget.cellWidget(int(row),0).currentText()
        # print("current combo_content:",combo_content)
        # self.current_mesh_group = [combo_content]
        # self._highlight_mesh_group()
        try:
            row = [self.ui.tableWidget.currentRow()]

        #rows = sorted(set([i.row() for i in selected] + [self.MyTable.currentRow()]), reverse=True)
            print("row:",row)
        #if (int(row[0]) != 0):
            combo_content = self.ui.tableWidget.cellWidget(int(row[0]),0).currentText()
            print("current combo_content:",combo_content)
            self.current_mesh_group = [combo_content]
            self._highlight_mesh_group()
        except:
            print("error,no row selected!")

    def current_combo_text_2(self):
        # selected = self.ui.tableWidget.selectedItems()
        # row = [self.ui.tableWidget.currentRow()]
        # row = int(row[0])
        # #rows = sorted(set([i.row() for i in selected] + [self.MyTable.currentRow()]), reverse=True)
        # print("row:",row)
        # #if (int(row[0]) != 0):
        # combo_content = self.ui.tableWidget.cellWidget(int(row),0).currentText()
        # print("current combo_content:",combo_content)
        # self.current_mesh_group = [combo_content]
        # self._highlight_mesh_group()
        try:
            row = [self.ui.tableWidget_2.currentRow()]

        #rows = sorted(set([i.row() for i in selected] + [self.MyTable.currentRow()]), reverse=True)
            print("row:",row)
        #if (int(row[0]) != 0):
            combo_content = self.ui.tableWidget_2.cellWidget(int(row[0]),0).currentText()
            print("current combo_content:",combo_content)
            self.current_mesh_group = [combo_content]
            self._highlight_mesh_group()
        except:
            print("error,no row selected!")


    def _highlight_mesh_group(self):
        #beam_list=['road','main_beams','lateral_beams','top_beams','bottom_beams']
        #rgb_list = [[1,0,0.498039],[0,0.333333,1],[0,1,0.333333],[1,1,0]]
        #index = self.ui.tabWidget_2.currentIndex()
        #print('index:',index)
        #var = beam_list[index]
        #index = combo.currentIndex()
        #index = 0
        #print("index:",index)
        #var = self.mesh_group[index]
        var = self.current_mesh_group[0]
        print("var:",var)
        #rgb = rgb_list[index]
        rgb = [0,1,0.333333]
        #if index !=0:
         #   self.beamsectionChanged.emit()
        #grtype = MeshGroupType.GElement
        grtype = MeshGroupType.GNode
        all_groups = get_medfile_groups(self.file_name, None, grtype)
        print('all_groups:',all_groups)
        for g in all_groups:
            self.meshGroupUnCheck.emit(self.file_name,
                                        self.nom_med,
                                        g,
                                        grtype)

        self.meshGroupCheckColor.emit(self.file_name,
                                        self.nom_med,
                                        var,
                                        grtype,
                                        rgb)

    def _highlight_mesh_group_2(self):
        #beam_list=['road','main_beams','lateral_beams','top_beams','bottom_beams']
        #rgb_list = [[1,0,0.498039],[0,0.333333,1],[0,1,0.333333],[1,1,0]]
        #index = self.ui.tabWidget_2.currentIndex()
        #print('index:',index)
        #var = beam_list[index]
        #index = combo.currentIndex()
        #index = 0
        #print("index:",index)
        #var = self.mesh_group[index]
        try:
            grtype = MeshGroupType.GNode
            all_groups = get_medfile_groups(self.file_name, None, grtype)
            print('all_groups:',all_groups)
            index = int(self.ui.comboBox.currentIndex())
            # print("index:",index)
            var = all_groups[index]
            print("var:",var)
            #rgb = rgb_list[index]
            rgb = [0,1,0.333333]
            #if index !=0:
            #   self.beamsectionChanged.emit()
            #grtype = MeshGroupType.GElement
            #grtype = MeshGroupType.GNode

            for g in all_groups:
                self.meshGroupUnCheck.emit(self.file_name,
                                            self.nom_med,
                                            g,
                                            grtype)

            self.meshGroupCheckColor.emit(self.file_name,
                                            self.nom_med,
                                            var,
                                            grtype,
                                        rgb)
        except:
            print("design area mesh highlight error!")
    
    def tab_changed(self):
        if self.ui.tabWidget.currentIndex == 1:
            self._highlight_mesh_group_2

    def med2inp(self):
        #import  SMESH, SALOMEDS
        #from salome.smesh import smeshBuilder
        unvdir = os.path.join(self.med_father_dir,"simple_test_copy.unv")
        external_file_export_to_med("unv",unvdir)
        #self.nom_med.ExportUNV(unvdir)
        # script = "med2unv.py"
        # script_dir = os.path.join(self.med_father_dir,script)
        # print("script_dir:",script_dir)
        # try:
        #     exec(open(script_dir,"rb").read())
        #     self.process.start('echo 运行参数化建模脚本中')
        # except:
        #     print("脚本错误!")
        #     self.process.start('echo 脚本错误！')

class Block:
    """Keyword block."""

    def __init__(self, keyword_name, comments, lead_line, data_lines):
        self.keyword_name = keyword_name # string
        self.comments = comments # list
        self.lead_line = lead_line # string
        self.data_lines = data_lines # list
    
    def get_inp_code(self):
        inp_code = []
        inp_code.extend(self.comments)
        inp_code.append(self.lead_line)
        inp_code.extend(self.data_lines)
        return inp_code

    def print_debug_info(self):
        sys.stdout.write('\nCOMMENTS:\n')
        for line in self.comments:
            sys.stdout.write(line + '\n')

        sys.stdout.write('LEAD:\n')
        sys.stdout.write(self.lead_line + '\n')

        sys.stdout.write('DATA:\n')
        for line in self.data_lines:
            sys.stdout.write(line + '\n')


class Importer:

    def __init__(self):
        from gui.window import wf
        self.w = Main() # master window
        self.keyword_blocks = []

    def split_on_blocks(self, inp_doc):
        """Split inp_doc on blocks."""
        self.keyword_blocks = []
        i = 0
        regex = r'^\*[\w\s-]+'
        while i < len(inp_doc):
            match = re.match(regex, inp_doc[i])
            if match is not None:
                keyword_name = match.group(0).strip()

                # Comments before the block
                comments = []
                counter = 0 # amount of comment lines
                while i > counter and inp_doc[i-counter-1].startswith('**'):
                    counter += 1
                    comments.insert(0, inp_doc[i-counter])

                # Lead line - a line(s) with keyword
                lead_line = inp_doc[i].rstrip()
                while lead_line.endswith(','):
                    i += 1
                    lead_line = lead_line + ' ' + inp_doc[i].rstrip()

                i += 1
                start = i # start of data lines
                while i < len(inp_doc):
                    match = re.match(regex, inp_doc[i])
                    if match is not None:
                        i -= 1
                        break # reached next keyword
                    i += 1

                # Comments after the block (if not EOF)
                if i < len(inp_doc) - 1:
                    while inp_doc[i].startswith('**'):
                        i -= 1
                end = i # index of block end

                data_lines = inp_doc[start:end+1]
                b = Block(keyword_name, comments, lead_line, data_lines)
                # b.print_debug_info()
                self.keyword_blocks.append(b)

            i += 1

    def parse_blocks(self):
        """Create keyword implementations."""
        parent = KOM.root
        messages = []

        for kwb in self.keyword_blocks:

            # Create implementations (for example, MATERIAL-1)
            kw = None
            while kw is None and parent is not None: # root has None parent
                kw = KOM.get_top_keyword_by_name(parent, kwb.keyword_name)
                if kw is not None:
                    parent = Implementation(kw, kwb.get_inp_code())
                else:
                    parent = parent.parent
            if kw is None:
                parent = KOM.root
                msg = 'Misplaced or wrong keyword {}.'\
                    .format(kwb.keyword_name)
                if msg not in messages:
                    messages.append(msg)
                    logging.warning(msg)

    def import_file(self, file_name):
        """Main method in the class"""
        #from gui.job import j
        j = Job()
        if file_name is None and self.w is None:
            msg = 'file_name and self.w are None.'
            raise SystemExit(msg)

        if file_name is None:
            file_name = QtWidgets.QFileDialog.getOpenFileName(self.w, \
                'Import INP/FBD/UNV file', j.dir, \
                'INP (*.inp);;FBD (*.fbd);;UNV (*.unv)')[0]

        if file_name is not None and len(file_name):
            self.w.textEdit.clear()

            # Update job instance before the tree regeneration
            # A new logger handler is created here
            j.generate(file_name[:-4] + '.inp')

            # Show model name in window title
            title = 'CalculiX Advanced Environment - ' + j.name
            self.w.setWindowTitle(title)

            from gui import stdout
            stdout.stop_readers()

            # Generate new KOM without implementations
            KOM.__init__()

            inp_files = []
            if file_name.lower().endswith('.inp'):
                inp_files.append(j.inp)

            # Convert UNV to INP
            if file_name.lower().endswith('.unv'):
                j.convert_unv()
                inp_files.append(j.inp)
                if not os.path.isfile(j.inp):
                    logging.error('Can not convert\n' + j.unv)
                    return

            # Pass FBD to CGX
            # from gui import cgx
            # if file_name.lower().endswith('.fbd'):
            #     """Get list of newly created or updated files."""
            #     flist_before = {}
            #     for f in os.listdir(os.path.dirname(file_name)):
            #         fname = pathlib.Path(f)
            #         flist_before[f] = fname.stat().st_ctime
            #     cgx.restart_and_read_fbd(file_name)
            #     flist_after = os.listdir(os.path.dirname(file_name))
            #     for f in flist_after:
            #         if not f in flist_before:
            #             inp_files.append(f)
            #         else:
            #             modified_before = flist_before[f]
            #             fname = pathlib.Path(f)
            #             modified_after = fname.stat().st_ctime
            #             if modified_before != modified_after:
            #                 inp_files.append(f)

            # Get INP code from all model files
            logging.info('Loading model files...')
            inp_doc = []
            for f in inp_files:
                logging.debug(f)
                inp_doc.extend(read_lines(f))

            # Split INP code on blocks - fill self.keyword_blocks
            self.split_on_blocks(inp_doc)

            # Parse keyword_blocks and enrich KOM with parsed objects
            self.parse_blocks()

            # Add parsed implementations to the tree
            #from tree.tree import t
            t = Main
            t.generateTreeView()

            # Parse mesh
            # TODO Use Mesh instead of m.Mesh
            from model.parsers import mesh
            m.Mesh = mesh.Mesh(blocks=self.keyword_blocks)

            # Open a new non-empty model in CGX
            from settings import s
            if not s.start_cgx_by_default:
                msg = '"Settings -> Start CGX by default" is unchecked.'
                logging.warning(msg)
                return
            if not len(m.Mesh.nodes):
                msg = 'Empty mesh, CGX will not start!'
                logging.warning(msg)
                return

            has_nodes = len(m.Mesh.nodes)
            # cgx.open_inp(j.inp, has_nodes)


# Prepare to import model



def read_lines(INP_file):
    """Recurcively reads all the INP file lines and its includes.
    Does not omit comments and empty lines.
    """
    INP_file = os.path.abspath(INP_file)
    if not os.path.isfile(INP_file):
        msg_text = 'File not found: ' + INP_file
        logging.error(msg_text)
        return []

    lines = []
    with open(INP_file, 'r', errors='ignore') as f:
        for line in f.readlines():
            line = line.strip()
            lines.append(line)

            # Append lines from include file
            if line.upper().startswith('*INCLUDE'):
                inc_file = line.split('=')[1].strip()
                inc_file = os.path.normpath(
                    os.path.join(os.path.dirname(INP_file), inc_file))
                lines.extend(read_lines(inc_file))

    return lines


class Job:

    def __init__(self):
        pass

    def generate(self, file_name=s.start_model):
        """Create job object.
        Is called from importer.py.
        """

        print('\nCREATING JOB INSTANCE.\n')

        self.dir = os.path.dirname(os.path.abspath(file_name)) # working directory
        self.name = os.path.basename(file_name) # INP file name
        self.inp = os.path.abspath(file_name) # full path to INP file with extension
        self.path = self.inp[:-4] # full path to INP without extension
        self.frd = self.path + '.frd' # full path to job results file
        self.log = self.path + '.log' # full path to job log file
        self.sta = self.path + '.sta' # full path to job status file

        print("self.inp is ",self.inp)
        print("self.dir is ",self.dir)
        # Remove old log_file
        if os.path.exists(self.log):
            os.remove(self.log)

        # Handler to write the job log file
        # logging.disable() TODO use it instead of log module
        log.remove_file_handler()
        copy_checks_log_contents_to(self.log)
        log.add_file_handler(self.log)

        logging.info('Application home directory is:\n'\
            + p.app_home_dir)
        os.chdir(self.dir)
        logging.info('Work directory is:\n' + self.dir)

    def convert_unv(self):
        """Convert UNV to INP."""
        import unv2ccx
        # converter_path = os.path.join(p.bin, 'unv2ccx' + p.extension)
        # cmd = [converter_path, self.path + '.unv']
        # logging.info(' '.join(cmd))
        # self.run(cmd)
        unv2ccx.Converter(self.path + '.unv').run()

    def monitor_status(self):
        """Open .sta file in external text editor."""
        # TODO Run as thread
        if os.path.isfile(s.path_editor):
            if os.path.isfile(self.sta):
                command = [s.path_editor, self.sta]
                subprocess.Popen(command)
            else:
                logging.error('File not found:\n' \
                    + self.sta \
                    + '\nSubmit analysis first.')
        else:
            logging.error('Wrong path to text editor:\n' \
                + s.path_editor \
                + '\nConfigure it in File->Settings.')

    """Menu Job."""

    def write_input(self, lines):
        """Write the whole model inp_code into the output .inp-file.
        Is called from menu 'Job -> Write input'.
        Reinitialize job because of possible file_name change.
        """
        file_name = QtWidgets.QFileDialog.getSaveFileName(None, \
            'Write INP file', self.dir, \
            'Input files (*.inp)')[0]
        if len(file_name):
            if not file_name.endswith('.inp'):
                file_name += '.inp'
            with open(file_name, 'w') as f:
                f.writelines(lines)
            logging.info('Input written to\n' + file_name)
            self.__init__(file_name)

            # Reopen CGX
            has_nodes = len(m.Mesh.nodes)
            from gui import cgx
            cgx.open_inp(self.inp, has_nodes)

    def open_inp(self):
        """Open INP file in external text editor."""
        if os.path.isfile(s.path_editor):
            if os.path.isfile(self.inp):
                command = [s.path_editor, self.inp]
                p = subprocess.Popen(command)
                return p
            else:
                msg = 'File not found:\n' \
                    + self.inp \
                    + '\nWrite input first.'
                logging.error(msg)
                return None
        else:
            msg = 'Wrong path to text editor:\n' \
                + s.path_editor \
                + '\nConfigure it in File->Settings.'
            logging.error(msg)
            return None

    def open_subroutine(self):
        """Dialog window to filter fortran subroutines."""
        if os.path.isfile(s.path_editor):
            file_name = QtWidgets.QFileDialog.getOpenFileName(None,
                'Open a subroutine', p.ccx, 'FORTRAN (*.f)')[0]
            if file_name:
                command = [s.path_editor, file_name]
                subprocess.Popen(command)
        else:
            logging.error('Wrong path to text editor:\n' \
                + s.path_editor \
                + '\nConfigure it in File->Settings.')

    def rebuild_ccx(self):
        """Recompile CalculiX sources with updated subroutines."""
        global thread_counter

        # Windows
        if os.name == 'nt':

            # Path to ccx sources
            ccx = path2cygwin(p.ccx)

            # Open bash and send command to build CalculiX
            cmd1 = 'C:\\cygwin64\\bin\\bash.exe --login'
            send1 = '/bin/make -f Makefile_MT -C {}'.format(ccx)

            # Move binary
            cmd2 = 'C:\\cygwin64\\bin\\mv.exe -T ' \
                    + ccx + '/ccx ' \
                    + p.bin + '/ccx'

        # Linux
        else:

            # Build CalculiX
            cmd1 = ['make', '-f', 'Makefile_MT', '-C', p.ccx]
            send1 = ''

            # Move binary
            cmd2 = ['mv', '-T', p.ccx + '/ccx',
                    p.bin + '/ccx']

        # Build CalculiX
        if type(cmd1) == str:
            logging.info(cmd1 + ' ' + send1)
        else:
            logging.info(' '.join(cmd1) + ' ' + send1)
        thread_counter += 1
        t_name = 'thread_{}_rebuild_ccx'.format(thread_counter)
        t = threading.Thread(target=self.run,
            args=(cmd1, send1), name=t_name, daemon=True)
        t.start()

    def submit(self):
        """Submit INP to CalculiX. Calculation starts in self.run method,
        which is called via thread to avoid GUI freeze.
        """
        global thread_counter

        if not os.path.isfile(p.path_ccx):
            logging.error('CCX not found:\n' \
                + p.path_ccx)
            return

        if os.path.isfile(self.inp):
            os.environ['OMP_NUM_THREADS'] = str(os.cpu_count()) # enable multithreading
            cmd = [p.path_ccx, '-i', self.path]
            logging.info(' '.join(cmd))

            thread_counter += 1
            t_name = 'thread_{}_submit_ccx'.format(thread_counter)
            t = threading.Thread(target=self.run,
                args=(cmd, '', True), name=t_name, daemon=True)
            t.start()
        else:
            logging.error('File not found:\n' \
                + self.inp \
                + '\nWrite input first.')

    def view_log(self):
        """Open log file in external text editor."""
        if os.path.isfile(s.path_editor):
            if os.path.isfile(self.log):
                command = [s.path_editor, self.log]
                p = subprocess.Popen(command)
                return p
            else:
                msg = 'File not found:\n' \
                    + self.log \
                    + '\nSubmit analysis first.'
                logging.error(msg)
                return None
        else:
            msg = 'Wrong path to text editor:\n' \
                + s.path_editor \
                + '\nConfigure it in File->Settings.'
            logging.error(msg)
            return None

    def export_vtu(self):
        """Convert FRD to VTU."""
        import ccx2paraview
        if os.path.isfile(self.frd):
            ccx2paraview.Converter(self.frd, ['vtu']).run()
        else:
            logging.error('File not found:\n' \
                + self.frd \
                + '\nSubmit analysis first.')

    def open_paraview(self):
        """Open VTU in ParaView."""
        if os.path.isfile(s.path_paraview):

            # Count result VTU files
            file_list = []
            for f in os.listdir(self.dir):
                f = os.path.basename(f)
                if f.lower() == self.name[:-4] + '.vtu':
                    file_list = [f]
                    break
                if f.lower().endswith('.vtu') and f.startswith(self.name[:-4]):
                    file_list.append(f)
            if len(file_list) > 1:
                vtu_path = self.path + '...vtu'
            elif len(file_list) == 1:
                vtu_path = self.path + '.vtu'
            else:
                logging.error('VTU file not found.\nExport VTU results first.')
                return

            command = [s.path_paraview, '--data=' + vtu_path]
            logging.info(' '.join(command))
            subprocess.Popen(command)
        else:
            logging.error('Wrong path to ParaView:\n' \
                + s.path_paraview \
                + '\nConfigure it in File->Settings.')

    def run(self, cmd, send='', read_output=True):
        """Run a single command, wait for its completion and log stdout.
        Doesn't block GUI, because is called in a separate thread.
        """
        while True:
            """Wait for previous thread to finish.
            t_names is a list of currently running threads names."""
            t_name = threading.current_thread().name
            t_names = sorted([t.name for t in threading.enumerate() \
                if '_ccx' in t.name])
            if t_name != t_names[0]:
                time.sleep(1)
            else:
                break

        # Run command
        process = subprocess.Popen(cmd,
            stdin=subprocess.PIPE,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT)
        if len(send):
            process.stdin.write(bytes(send, 'utf8'))
            process.stdin.close()

        # Start stdout reading and logging thread
        args = [process.stdout, 'read_stdout', read_output]
        from gui import stdout
        stdout.start_reader(*args)

        while process.poll() is None:
            time.sleep(1)


def path2cygwin(path):
    """Converts Windows path to Cygwin path."""
    return '/cygdrive/' + \
            path[0].lower() + \
            path[2:].replace('\\', '/')

def copy_checks_log_contents_to(job_logfile):
    """Copy logs from startup checks into the job logfile.
    TODO Remove checks.log after.
    """
    checks_log = os.path.join(p.src, 'checks.log')
    if not os.path.isfile(checks_log):
        return
    lines = []
    with open(checks_log, 'r') as f:
        lines = f.readlines()
    with open(job_logfile, 'w') as f:
        f.writelines(lines)
        f.write('\nAPPLICATION START\n\n')
    # os.remove(checks_log)
def read_lines(INP_file):
    """Recurcively reads all the INP file lines and its includes.
    Does not omit comments and empty lines.
    """
    INP_file = os.path.abspath(INP_file)
    if not os.path.isfile(INP_file):
        msg_text = 'File not found: ' + INP_file
        logging.error(msg_text)
        return []

    lines = []
    with open(INP_file, 'r', errors='ignore') as f:
        for line in f.readlines():
            line = line.strip()
            lines.append(line)

            # Append lines from include file
            if line.upper().startswith('*INCLUDE'):
                inc_file = line.split('=')[1].strip()
                inc_file = os.path.normpath(
                    os.path.join(os.path.dirname(INP_file), inc_file))
                lines.extend(read_lines(inc_file))

    return lines


if __name__ == '__main__':
    app = QApplication(sys.argv)
    demo = Main(1)
    demo.show()
    sys.exit(app.exec_())

