from asyncio.log import logger
from curses.panel import bottom_panel
import queue
from re import L
from turtle import update
from .crontrol_ui_process import Ui_Form
from PyQt5 import Qt as Q
from PyQt5 import QtCore, QtWidgets
from PyQt5.QtWidgets import QDialog
from PyQt5.QtCore import QObject, pyqtSignal, pyqtSlot
from PyQt5.QtCore import *
from PyQt5.QtWidgets import *
from PyQt5.QtGui import *
import time, os

from ...common import load_icon
from .path import p

class Maincontrol(Q.QWidget):
    def __init__(self,qianchuli):
        super(Maincontrol,self).__init__()
        self.ui = Ui_Form()
        self.ui.setupUi(self)
        # 给按钮添加图标
        self.add_icon()

        self.thread = None  # 初始化线程

        # QProcess object for external app
        self.process_ccx2vtk = Q.QProcess(self)

        self.process_fem = Q.QProcess(self)
        self.process_fem.readyRead.connect(self.dataReady)
        # self.process.started.connect(lambda: self.bt1.setEnabled(False))
        # self.process.finished.connect(lambda: self.bt1.setEnabled(True))
        self.process_fem.setProcessChannelMode(Q.QProcess.MergedChannels)

        self.process_opt = Q.QProcess(self)
        self.process_opt.readyRead.connect(self.dataReady_opt)
        self.process_opt.setProcessChannelMode(Q.QProcess.MergedChannels)

        self.ui.pushButton_2.clicked.connect(self.start_fem)
        self.ui.pushButton.clicked.connect(self.kill_fem)

        self.pv = 0
        self.ui.progressBar.setMinimum(0)
        self.ui.progressBar.setMaximum(100)
        self.ui.progressBar.setValue(self.pv)
        
        self.ui.pushButton_3.clicked.connect(self.start_opt)
        self.ui.pushButton_4.clicked.connect(self.kill_opt)

        self.ui.comboBox_2.addItems(['q_x86_sf'])
        self.ui.comboBox.addItems(['1','2','4','8','16','32'])

        self.read_config()

    def add_icon(self):
        self.ui.pushButton_2.setIcon(load_icon('startdefault.png'))
        self.ui.pushButton_3.setIcon(load_icon('startdefault.png'))
        self.ui.pushButton.setIcon(load_icon('halt.png'))
        self.ui.pushButton_4.setIcon(load_icon('halt.png'))

    def dataReady(self):
        #self.keyboardWidget = KeyboardWidget()
        self.simulationOutput = self.ui.textBrowser.textCursor()
        processStdout = bytearray(self.process_fem.readAllStandardOutput())
        processStdout = processStdout.decode(encoding='UTF-8',errors='strict')
        newCursor1 = self.ui.textBrowser.textCursor()
        newCursor1.movePosition(Q.QTextCursor.End)
        self.ui.textBrowser.setTextCursor(newCursor1)
        self.simulationOutput = self.ui.textBrowser.textCursor()
        self.simulationOutput.insertText(processStdout)

    def dataReady_opt(self):
        #self.keyboardWidget = KeyboardWidget()
        self.OptOutput = self.ui.textBrowser_2.textCursor()
        processStdout = bytearray(self.process_opt.readAllStandardOutput())
        processStdout = processStdout.decode(encoding='UTF-8',errors='strict')
        newCursor1 = self.ui.textBrowser_2.textCursor()
        newCursor1.movePosition(Q.QTextCursor.End)
        self.ui.textBrowser_2.setTextCursor(newCursor1)
        self.OptOutput = self.ui.textBrowser_2.textCursor()
        self.OptOutput.insertText(processStdout)

    def start_fem(self):
        self.ui.pushButton_2.setEnabled(False)
        self.num_pro = self.ui.comboBox.currentText()
        self.queue = self.ui.comboBox_2.currentText()
        self.read_config()
        cmd = 'sh ' + p.fem_run
        cmd = cmd + " " + str(self.num_pro) + " " + self.current_working_dir
        cmd = cmd + " " + str(self.queue) + " " + self.model
        print("fem_run command:",cmd)
        #self.process_fem.start(cmd)

        # self.fem_frd = self.model + '.frd'
        # cmd = 'sh ' + p.ccx2paraview_run + " " + p.ccx2paraview + " " + self.fem_frd
        # print("sh ccx2paraview_run:",cmd)
        #self.process_ccx2vtk.start(cmd)
        self.process_fem.start(cmd)
        self.process_fem.waitForFinished(5000)
        self.ui.pushButton_2.setEnabled(True)
    
    def kill_fem(self):
        self.process_fem.kill()
        self.simulationOutput.insertText("——————计算被手动终止！——————" + "\n")

    def start_opt(self):
        self.ui.pushButton_3.setEnabled(False)
        self.num_pro = self.ui.comboBox.currentText()
        self.queue = self.ui.comboBox_2.currentText()
        #self.item,ok = QtWidgets.QInputDialog.getText(self,'优化设置',['最大迭代次数：','目标收敛容差：'])
        self.iterations_max = 0
        convergence_tolerance = 0
        self.iterations_max,convergence_tolerance = self.opt_dialog()

        # file_name = os.path.basename(str(self.model)) + '.inp'
        # path = os.path.join(self.current_working_dir,'opt')
        # file_dir = os.path.join(path,file_name) # initial file name is the same as inp file 

        # if os.path.exists(file_dir):
        if self.iterations_max and convergence_tolerance:
            cwd = os.path.join(self.current_working_dir,'opt')
            cmd = '/opt/skyformai/bin/csub -I -cwd ' + str(cwd) + ' ' + '-J "shape_optimization"'
            cmd = cmd + ' ' + '-q' + ' ' + str(self.queue) + ' ' + '-n' + ' ' + str(self.num_pro) + ' '
            cmd = cmd + 'python3 ' + p.opt_run
            cmd = cmd + " " + str(self.num_pro) + " " + self.current_working_dir
            cmd = cmd + " " + str(self.queue) + " " + self.model
            cmd = cmd + " " + str(self.iterations_max) + " " + str(convergence_tolerance)
            print("opt_run command:",cmd)
            self.process_opt.start(cmd)
            self.process_opt.waitForFinished(5000)
            self.open_log()
            self.ui.pushButton_3.setEnabled(True)
        
        # else:
        #     QtWidgets.QMessageBox.information(self, '提示', '请先进行有限元仿真计算!')

    def kill_opt(self):
        self.process_opt.kill()
        self.OptOutput.insertText("——————计算被手动终止！——————" + "\n")
        
    def read_config(self):
        with open(p.user_settings, 'r') as f:
            for line in f.readlines():
                if(line.find('self.start_model') == 0):
                    self.model = line.split()[2]
                    self.model = self.model[1:-5] # *.inp
                    print('current_moel',self.model)
                if(line.find('self.working_dir') == 0):
                    self.current_working_dir = line.split()[2]
                    self.current_working_dir = self.current_working_dir[1:-1]
                    print('current_working_dir:',self.current_working_dir)

    def open_log(self):
        # 创建线程
        self.thread = Runthread_Log(self.current_working_dir,self.model)
        # 连接信号
        self.thread._signal.connect(self.append_line)  # 线程连接回传到GUI的事件
        #self.thread._signal_iter.connect(self.update_processBar)
        # 开始线程
        self.thread.start()

    def append_line(self, line):
        self.ui.textBrowser_3.append(line)
        if line[0:9] == "iteration":
            self.update_processBar(line)

    def update_processBar(self, line):
        iter = line.split()[2]
        process = round(int(float(iter))/int(float(self.iterations_max)),2)*100
        self.ui.progressBar.setValue(process)
        
    def opt_dialog(self):
        dialog = QDialog(self)  # 自定义一个dialog
        dialog.setWindowTitle('Opt Settings')
        formLayout = QFormLayout(dialog)  # 配置layout
        iterations_max = QLineEdit()
        iterations_max.setText('30')
        convergence_tolerance = QLineEdit()
        convergence_tolerance.setText('0.001')
        formLayout.addRow('最大迭代次数', iterations_max)
        formLayout.addRow('目标收敛容差', convergence_tolerance)
        button_ok = QDialogButtonBox(QDialogButtonBox.Ok)
        bottom_cancel = QDialogButtonBox(QDialogButtonBox.Cancel)
        formLayout.addRow(button_ok,bottom_cancel)
        dialog.show()
        button_ok.clicked.connect(dialog.accept)
        bottom_cancel.clicked.connect(dialog.close)

        if dialog.exec() == QDialog.Accepted:
            return iterations_max.text(), convergence_tolerance.text()
        else:
            return 0,0

class Runthread_Log(QtCore.QThread):
    #  通过类成员对象定义信号对象
    _signal = pyqtSignal(str)
    #_signal_iter = pyqtSignal(str)

    def __init__(self,work_dir,model_dir):
        super(Runthread_Log, self).__init__()
        self.working_dir = work_dir
        self.model = model_dir
        self.log_name = os.path.basename(self.model) + '.log'
        self.opt_path = os.path.join(self.working_dir,'opt')
        self.logger_path = os.path.join(self.opt_path,self.log_name)

        self.process_ccx2vtk = Q.QProcess(self)
        self.fem_frd = self.model + '.frd'
        cmd = 'sh ' + p.ccx2paraview_run + " " + p.ccx2paraview + " " + self.fem_frd
        print("sh ccx2paraview_run:",cmd)
        self.process_ccx2vtk.start(cmd)

    def __del__(self):
        self.wait()
	
	#实时加载文件的更新内容并输出到textBrowser
    def run(self):
        f = open(self.logger_path, 'r', encoding='utf-8')

        while 1:
            where = f.tell()
            line = f.readline()
            if not line:
                self.sleep(1)
                f.seek(where)
            else:
                self._signal.emit(line)
                # if line.find("iteration"):
                #     self._signal_iter.emit(line[9:-1])
